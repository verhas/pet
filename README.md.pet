{%
use('text')
use('counters')
VERSION=text("1.0.0")
ch = ChapterCounter()
n = 1
def c():
    global n
    print(f"{n}",end='')
    n = n + 1
%}
{%ch();ch.open()%} Program Enhanced Text (PET) {% VERSION() %}

Program Enhanced Text (PET) is not a program.
It is more like a methodology.
It aims to create maintainable documentation utilizing some markup and minimizing manual maintenance.
After reading this short readme, you will see that there is nothing radically new in PET.
It is more about utilizing existing tools in the simplest possible way with a clear goal of improving software documentation quality.

One can argue that PET is nothing but text templating, and they are not wrong.
Others may say it is text with macros.
Someone may mention some other tools.

There are various tools available for implementing PET documentation.
You should select the one that best fits your purpose and possibilities.

The author of this document has also created multiple tools over the years, which are also available if one selects them as the best for their use.

In this document, I will explain the central questions of PET:

* {%CH1=text(" What is PET?"); CH1()%}

* {%CH2=text(" What are the issues that PET solves?");CH2() %}

* {%CH3=text(" How to Apply PET in the Most Effective Ways."); CH3()%}

{%ch(); CH1()%}

PET is a document maintenance automation philosophy.
It says that

>a person (human) should not maintain any aspect of a document that can be automated.

A simple example is when you include sample code in your documentation.
The conventional solution is to copy the code and paste it into the document with some formatting markup.
When the new release of the software is documented and the sample code has been updated, the process is repeated.
Many times, it is not repeated, and the sample code in the documentation remains outdated.

Using PET, you maintain a PET-enhanced document, which is one phase before the markup version of the final document.
This PET-enhanced document references the code to be copied into the document, rather than including a copy.
When the document is processed, the sample code is fetched from the source code automatically and inserted into the markup.
Including this step in the software build process ensures that the update of the changed code sample is never overlooked.

Please note that the sample code is provided for illustrative purposes only.
There are many more things that you can automate using PET.
You can fetch:

* configuration keys, which may be renamed in different software versions,
* version information of the source code
* list of features implemented in the code, and so on.

If the information we need to include in the documentation is already available somewhere, then a human should not recreate it manually.

The information may come from various sources.
In the example above, the source sample came from the documented system, the program.
It may also be available in some already existing part of the document.
It can be somewhere in the environment.

Regardless of the source, if the inclusion of information into the document can be automated, it should be automated.

{%ch(); CH2()%}

As we have already discussed, PET eliminates the errors that result from the collision of redundancy and human maintenance.
Humans are not good at doing tasks repetitively; machines are.

Here are the main issues PET aims to solve:

{%c()%}. Outdated or inconsistent documentation

When information is copied manually into documentation, there is a high risk that updates in the source are not reflected in the docs. PET ensures that documents stay in sync with their sources automatically.

{%c()%}. High maintenance costs

Manual updates introduce overhead. Developers and technical writers spend time locating and updating repeated information across different documents. PET reduces this effort by introducing automation.

{%c()%}. Error-prone duplication

Redundant information—when not managed programmatically—leads to inconsistencies. PET promotes a single source of truth, pulling data or text dynamically from its original source.

{%c()%}. Delayed documentation updates

When updating documentation is a manual chore, it often gets postponed or skipped entirely. PET makes updates a side-effect of the build or deployment process, minimizing human procrastination.

{%c()%}. Lack of trust in documentation

When readers repeatedly encounter outdated or inaccurate information, they lose trust in the documentation. PET helps restore that trust by making documents more reliable and up-to-date.

## {%CH3()%}

To apply PET most effectively, the goal should always be clarity, maintainability, and reduction of manual effort. Here are key strategies:

{%n=1;c()%}. Use a consistent templating engine

Choose a text templating system suitable for your environment.
You can use Jamal, Jinja2, or even a custom processor, like in this document.
Consistency in tooling makes maintenance and onboarding easier.

{%c()%}. Externalize the changeable

Move all dynamic or frequently changing content (e.g., code samples, config keys, version numbers) out of the static document.
Reference them through PET macros that fetch the current value automatically.

{%c()%}. Integrate PET processing into the build

Integrate the PET-to-markup transformation into your CI/CD or documentation build pipeline.
This ensures up-to-date documents without requiring manual intervention in separate steps.

{%c()%}. Use PET selectively

Not all parts of a document benefit from automation. Use PET where redundancy is a risk or where automation yields significant time savings. Avoid adding complexity for its own sake.

{%c()%}. Validate the output

Automated documentation still needs review. Add validation steps to check that the final rendered documents are complete, readable, and consistent with expectations.

{%ch()%} PET the simplest way

This document and the repository are an example of how to use PET with minimal tooling.
The author of this document created Jamal and other similar tools with limited effort.
Jamal, or Pyama, are usable and professional tools, but the starting threshold seems to be too high.
There is a very limited user base for those tools.

It does not mean, however, that PET as a general concept cannot be used.
This repository contains a minimalistic Python script of less than 100 lines that implements the simplest templating ever.
This is enough to use PET.

Include your Python code in the `XYZ.md.pet` document between {% print("`{%`",end='')%} and `%}` strings.
Create simple libraries, such as those found in this repository's `.pet` directory.
The templating provides a function `use()` to include these classes and definitions into your document.

To get the `XYZ.md` you can run

```
python3 pet.py XYZ.md.pet XYZ.md
```

or even

```
fswatch -o README.md.pet | xargs -n1 -I{} sh -c 'echo "File changed, regenerating..." && python3 pet.py XYZ.md.pet XYZ.md'
```

to have a constant running background process while you edit your `md.pet` file.

*NOTE:* You can use any format, not only Markdown.

Currently, there are two "macro" classes in this directory.
One can be used to define texts and then use them.
The other one can be used to number sections in Markdown documents.
Later, you may find other simple tools in this repository.



{%ch()%} Summary

